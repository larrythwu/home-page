<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Mini OS - Larry Wu</title>
  <link rel="stylesheet" href="../css/styles.css">
  <style>
    .description-container {
      max-width: 1000px;
      margin: 0 auto;
      padding: 40px 20px;
      text-align: left;
      line-height: 1.6;
    }
    .project-header {
      display: flex;
      align-items: center;
      margin-bottom: 30px;
      padding-bottom: 20px;
      border-bottom: 2px solid #eee;
    }
    .project-header img {
      width: 4rem;
      margin-right: 15px;
    }
    .project-header h3 {
      font-size: 2rem;
      margin: 0;
      color: #333;
    }
    .card-container {
      margin-bottom: 40px;
    }
    .card {
      width: 100%;
      border: 1px solid rgba(0,0,0,0.1);
      border-radius: 8px;
      margin-bottom: 25px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
      transition: transform 0.2s ease;
    }
    .card:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    }
    .card-header {
      padding: 15px 20px;
      background-color: #f8f9fa;
      border-bottom: 1px solid rgba(0,0,0,0.1);
      font-weight: 600;
      font-size: 1.2rem;
      border-radius: 8px 8px 0 0;
    }
    .card-body {
      padding: 25px;
      text-align: left;
    }
    .card img {
      max-width: 60%;
      height: auto;
      display: block;
      margin: 20px auto;
      border-radius: 4px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .link {
      color: #0066cc;
      text-decoration: none;
      transition: color 0.2s ease;
    }
    .link:hover {
      color: #004499;
      text-decoration: underline;
    }
    .repo-link {
      display: flex;
      align-items: center;
      margin: 30px 0;
      padding: 15px;
      background-color: #f8f9fa;
      border-radius: 8px;
      transition: background-color 0.2s ease;
    }
    .repo-link:hover {
      background-color: #e9ecef;
    }
    .repo-link img {
      width: 32px;
      margin-right: 15px;
    }
    .repo-link a {
      font-size: 1.1rem;
      font-weight: 500;
    }
    ol, ul {
      padding-left: 40px;
      margin: 15px 0;
    }
    li {
      margin: 8px 0;
      padding-left: 10px;
    }
    li ul, li ol {
      padding-left: 30px;
      margin: 8px 0;
    }
    .resources-section ul, .tools-section ul {
      padding-left: 40px;
    }
    .resources-section li, .tools-section li {
      padding-left: 10px;
    }
    p {
      margin: 15px 0;
    }
    strong {
      color: #333;
    }
    .resources-section {
      margin-top: 20px;
      padding: 15px;
      background-color: #f8f9fa;
      border-radius: 8px;
    }
    .resources-section p {
      margin: 0 0 10px 0;
      font-weight: 600;
    }
    .tools-section {
      margin-top: 40px;
      padding: 25px;
      background-color: #f8f9fa;
      border-radius: 8px;
    }
    .tools-section p {
      margin: 0 0 15px 0;
      font-weight: 600;
    }
  </style>
</head>
<body>
  <div class="app">
    <!-- Navigation -->
    <nav class="navbar">
      <div class="navbar-container">
        <a href="../index.html" class="navbar-brand">Larry Wu</a>
        <ul class="navbar-nav">
          <li class="nav-item">
            <a class="nav-link" href="../index.html">Home</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="../resume.html">Resume</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="../projects.html">Projects</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="../photography.html">Photography</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="../paintings.html">Paintings</a>
          </li>
        </ul>
      </div>
    </nav>

    <!-- Mini OS Content -->
    <div class="description-container">
      <div class="project-header">
        <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/d/da/GNOME_Terminal_icon_2019.svg/1200px-GNOME_Terminal_icon_2019.svg.png" alt="Mini OS Icon">
        <h3>MiniOS</h3>
      </div>

      <p>This project is inspired by Prof. Yuan Ding's <a class="link" href="https://www.eecg.utoronto.ca/~yuan/teaching/ece344/">ECE344 Operating System</a> at the University of Toronto. In this course, we implemented core kernel features for the <a class="link" href="http://www.os161.org/">OS161</a> project. Having learned the foundations of kernel hacking, I want to challenge myself to build a fully functional kernel from the ground up.
      So I started digging online and found this <a class="link" href="https://www.udemy.com/course/developing-a-multithreaded-kernel-from-scratch/">amazing tutorial</a> by Daniel McCarthy. Following Daniel's tutorial and other documentation online, I was able to successfully implement and execute my kernel on a QEMU x86 emulator. The following sections describe the key features of my kernel and some resources that I found to be helpful.</p>

      <p>Feel free to clone my repo and run it yourself…</p>
      <div class="repo-link">
        <img src="https://img.icons8.com/fluent/144/000000/github.png" alt="GitHub Logo">
        <a class="link" href="https://github.com/larrythwu/myOS" target="_blank">Mini OS</a>
      </div>

      <div class="card-container">
        <div class="card">
          <div class="card-header">
            <a class="link" href="https://github.com/larrythwu/myOS/blob/main/src/boot/boot.asm">Bootloader</a>
          </div>
          <div class="card-body">
            <p>A bootloader is a tiny software that helps the CPU to load the operating system. It is stored in the first sector of the hard drive.
            The CPU automatically reads the data contained in this first sector and processes it to the memory when the machine is powered up.</p>

            <img src="../images/projects/mini_os/bootloader.png" alt="Bootloader">

            <p>Internally the bootloader's Master Boot Record contains the following submodules:</p>
            <ol>
              <li><strong>Define the BIOS Parameter Block:</strong> BPB specifies the parameter of the hard drive, including the filesystem used and the physical geometry of the disk.</li>
              <li><strong>Loading the kernel from disk using BIOS:</strong> to read data from disk, we need to specify where to start reading, how much to read, and where to store the data in memory. We can then send an interrupt signal (int 0x13) and the BIOS will do its work.</li>
              <li><strong>Setup Global Descriptor Table:</strong> GDT is a data structure used by x86 processors to define the characteristics of the various memory areas used during program execution. Our GDT is structured as follows:
                <ul>
                  <li>A null segment address 0x00000000</li>
                  <li>4GB code segment descriptor</li>
                  <li>4GB data segment descriptor</li>
                </ul>
              </li>
              <li><strong>Switch to 32 bit protected mode:</strong> in protected mode, the system software is allowed to use features like virtual memory and paging.</li>
              <li><strong>Kernel entry:</strong> jump to the main function of our kernel program</li>
            </ol>
            <div class="resources-section">
              <p>Resources:</p>
              <ul>
                <li><a class="link" href="https://www.apriorit.com/dev-blog/66-develop-boot-loader">https://www.apriorit.com/dev-blog/66-develop-boot-loader</a></li>
                <li><a class="link" href="https://dev.to/frosnerd/writing-my-own-boot-loader-3mld">https://dev.to/frosnerd/writing-my-own-boot-loader-3mld</a></li>
                <li><a class="link" href="https://www.udemy.com/course/developing-a-multithreaded-kernel-from-scratch/learn/lecture/23967076#overview">https://www.udemy.com/course/developing-a-multithreaded-kernel-from-scratch/learn/lecture/23967076#overview</a></li>
              </ul>
            </div>
          </div>
        </div>

        <div class="card">
          <div class="card-header">
            <a class="link" href="https://github.com/larrythwu/myOS/tree/main/src">Kernel</a>
          </div>
          <div class="card-body">
            <p>In this section, we set up the core kernel features such as:</p>
            <ol>
              <li><a class="link" href="https://github.com/larrythwu/myOS/tree/main/src/idt"><strong>Interrupt Descriptor Table:</strong></a> a data structure used by x86 to determine the correct handler routine for interrupts and exceptions. The IDT consists of 256 interrupt vectors, the first 32 (0–31 or 0x00–0x1F) are used for processor exceptions, such as division by 0.</li>
              <img src="../images/projects/mini_os/IDT.png" alt="IDT">

              <li><a class="link" href="https://github.com/larrythwu/myOS/tree/main/src/memory/heap"><strong>Heap Memory Allocation:</strong></a> for simplicity, we used an allocation table composed of an array of 1-byte values each representing a (4k) page allocation in the heap. This implementation is subjected to a lot of fragmentation and latency issues, but it's easy to write. Each entry in the table has the following property:</li>
              <img src="../images/projects/mini_os/heap.png" alt="Heap">
              <ul>
                <li>HAS_N: if the next entry is part of the allocation</li>
                <li>IS_FIRST: set if this is the first entry of our allocation</li>
                <li>ET: specify if the page is allocated or free</li>
              </ul>

              <li><a class="link" href="https://github.com/larrythwu/myOS/tree/main/src/memory/paging"><strong>Virtual Memory:</strong></a> Paging is a system that allows each process to see a full virtual address space, without actually requiring the full amount of physical memory to be available or present. Paging is achieved through the use of the Memory Management Unit (MMU). On the x86, the MMU maps memory through a series of tables, two to be exact. They are the paging directory (PD), and the paging table (PT).</li>
              <img src="../images/projects/mini_os/paging.png" alt="Paging">
              <p>We enable paging by loading the CR3 register with the address of the page directory and to set the paging (PG) and protection (PE) bits of CR0. <a class="link" href="https://en.wikipedia.org/wiki/Control_register#CR0">https://en.wikipedia.org/wiki/Control_register#CR0</a></p>

              <li><a class="link" href="https://github.com/larrythwu/myOS/tree/main/src/filesystem"><strong>FAT16 file system:</strong></a> file allocation table is a filesystem developed by Microsoft, FAT uses clusters to represent data and subdirectories. The entire disk is divided into clusters, the unit used by the file allocation, and the FAT describes which clusters are used by which files.</li>
              <img src="../images/projects/mini_os/FAT.png" alt="FAT">
            </ol>
            <p>Resources:</p>
            <ul>
              <li><a class="link" href="https://wiki.osdev.org/Paging#32-bit_Paging">https://wiki.osdev.org/Paging#32-bit_Paging</a></li>
              <li><a class="link" href="https://wiki.osdev.org/FAT#FAT_16">https://wiki.osdev.org/FAT#FAT_16</a></li>
            </ul>
          </div>
        </div>

        <div class="card">
          <div class="card-header">
            <a class="link" href="https://github.com/larrythwu/myOS/tree/main/programs">Userland</a>
          </div>
          <div class="card-body">
            <p>The userland is the unprivileged CPU state, all the regular programs run here and they communicate with the kernel via interrupts and the standard library. We also develop a shell program that can be used to launch other executables. But before entering the userland, we still have a few things left to do in the kernel:</p>
            <ol>
              <li><a class="link" href="https://github.com/larrythwu/myOS/tree/main/src/task"><strong>Defining a process:</strong></a> we use kernel processes to host a user application, each process stores the following information:
                <ul>
                  <li>the registers needed to run the user program</li>
                  <li>the paging directory</li>
                  <li>the next and prev task, so that the kernel can switch between the tasks in a round-robin fashion to achieve multi-tasking</li>
                </ul>
                <p>In our implementation, all the processes share the same file descriptor table, so all the opened files are shared which differs from the traditional Linux kernel.</p>
              </li>
              <li><a class="link" href="https://github.com/larrythwu/myOS/blob/main/src/task/task.asm"><strong>Getting to the userland from the kernel:</strong></a> to go from the kernel into the userland, we need to:
                <ol type="a">
                  <li>Setup user code and data segments</li>
                  <li>Setup the Task Switch Segment: it is used by the processor to get back to the kernel land when we have a system interrupt. It stores the kernel data segment descriptor and the value of the stack pointer used by the kernel</li>
                  <li>Use the "iret" instruction to change the processor's privilege state</li>
                </ol>
              </li>
            </ol>
            <p>Our user-level programs:</p>
            <ul>
              <li><a class="link" href="https://github.com/larrythwu/myOS/tree/main/programs/stdlib"><strong>Standard library implementation:</strong></a> we implemented the following stdlib functions that require system calls (int 0x80) to the kernel:
                <ul>
                  <li>printf: print strings to the terminal</li>
                  <li>getkey: return the latest keypress in the keyboard buffer</li>
                  <li>malloc: return the virtual address of a heap allocation</li>
                  <li>free: deallocate a heap allocation</li>
                </ul>
              </li>
              <li><a class="link" href="https://github.com/larrythwu/myOS/tree/main/programs/shell"><strong>Shell program:</strong></a> the shell program is the default user program that will be run by the kernel, it can display the list of files that we mounted to the disk and launch the binary files as a separate task. Whenever a user program finishes executing, the control returns to the shell program.</li>
            </ul>
          </div>
        </div>
      </div>

      <div class="tools-section">
        <p><strong>List of software tools:</strong></p>
        <ul>
          <li><strong>Cross-compiler:</strong> a cross-compiler is a compiler that runs on platform A (the host), but generates executables for platform B (the target). In our case, the host platform is your current operating system and the target platform is the operating system you are about to make. In this project, the target is the generic i686-elf-gcc.</li>
          <li><strong>Qemu:</strong> QEMU is a free and open-source emulator that performs hardware virtualization. It is capable of emulating a wide variety of systems including ARM, x86, and RISC-V, among others.</li>
          <li><strong>GDB:</strong> a source-level debugger that can be used with the Qemu emulator</li>
        </ul>
      </div>
    </div>
  </div>
</body>
</html>